<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        {
            // 함수의 정의 (함수 선언문)
            function square(number) {
                return number * number;
            }

            // 함수의 호출
            console.log(square(2));
        }
        // 자바스크립트의 함수는 객체(일급 객체; First-class object)이다.
        // 다른 객체와 구분될 수 있는 특징은 호출될 수 있다는 것이다. 함수도 객체이므로 다른 값들처럼 사용할 수 있다. 즉, 변수나 객체, 배열 등에 저장할 수 있고 다른 함수에 전달되는 인수로도 사용될 수 있으며 함수의 반환값이 될 수도 있다.

        {
            // 함수를 배열에 저장
            // 함수는 전역적이다.
            arr = [square];
            console.log(arr[0](5));
        }

        // #1. 함수 정의
        // #1.1 함수 선언문
        {
            // 함수 선언문
            function square(number) {
                return number * number;
            }
            // 함수 선언문 ==> 함수 표현식
            // let square = function square(number) {
            //     return number * number;
            // };
        }

        // #1.2 함수 표현식(일급 객체)
        // 1) 무명의 리터럴로 표현이 가능하다.
        // 2) 변수나 자료 구조(객체, 배열...)에 저장할 수 있다.
        // 3) 함수의 파라미터로 전달할 수 있다.
        // 4) 반환값(return value)으로 사용할 수 있다.
        {
            // 함수 표현식
            let square = function(number) {
                return number * number;
            };
            // 함수 표현식 방식으로 정의한 함수는 함수명을 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다.
            // 함수 표현식에서는 함수명을 생략하는 것이 일반적이다.

            // 기명 함수 표현식(named function expression)
            let foo = function multiply(a, b) {
                return a * b;
            };
            console.log(typeof foo);
            console.log(typeof multiply);

            let bar = function(a, b) {
                return a * b;
            };

            console.log(typeof bar);
            console.log(foo(10, 5));
            // console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined
            console.log(bar(10, 5));

            foo = function(a, b) {
                return a * b;
            };

            bar = foo;
            console.log(foo(10, 10));
            console.log(bar(10, 10));
        }

        // #1.3 Function 생성자 함수
        // 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데 이것은 결국 내장 함수 Function 생성자 함수를 생성하는 것을 단순화시킨 short-hand(축약법)이다.
        {
            // Function 생성자 함수로 함수를 생성하는 문법은 다음과 같다.
            // new Function(arg1, arg2, ..., argn, functionBody)
            let square = new Function('number', 'return number * number');
            console.log(square(10, 10));
            // Function 생성자 함수로 생성하는 방식은 일반적으로 사용하지 않는다.
        }

        // #2. 함수 호이스팅
        {
            let res = square2(5);
            console.log(res);

            // 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 이것을 함수 호이스팅(Function Hoisting)이라 한다.
            function square2(number) {
                return number * number;
            }

            // Uncaught ReferenceError: Cannot access 'square2' before initialization
            // let square2 = function square2(number) {
            //     return number * number;
            // }


            // 함수 선언문과 달리 TypeError가 발생했다. 함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.
            // 변수 호이스팅은 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undifined로 초기화 되고 실제값의 할당은 할당문에서 이루어진다.
            // Uncaught TypeError: square2 is not a function
            // var square2 = function square2(number) {
            //     return number * number;
            // }

            // 함수 호이스팅은 함수 호출 전 반드시 함수를 선언해야한다는 규칙을 무시하므로 코드의 구조를 엉성하게 만들 수 있다. 따라서 함수 표현식만을 사용할 것을 권고한다.
        }

        // #3. First-class object(일급객체)
        // 일급 객체(first-class object)란 생성, 대입, 연산 또는 반환값으로서의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미한다.
        // 다음 조건을 만족하면 일급 객체로 간주한다.
        // 1) 무명의 리터럴로 표현이 가능하다.
        // 2) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
        // 3) 함수의 매개변수에 전달할 수 있다.
        // 4) 반환값으로 사용할 수 있다.
        {
            // 1) 무명의 리터럴로 표현이 가능하다.
            // 2) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
            let increase = function(num) {
                return ++num;
            };
            
            let decrease = function(num) {
                return --num;
            };

            let predicates = {increase, decrease};
            console.log(typeof predicates, predicates);

            // 3) 함수의 매개변수에 전달할 수 있다.
            // 4) 변환값으로 사용할 수 있다.
            function makeCounter(predicates) {
                let num = 0;

                return function() {
                    num = predicates(num);
                    return num;
                };
            }

            let increaser = makeCounter(predicates.increase);
            console.log(increaser());
            console.log(increaser());

            let decreaser = makeCounter(predicates.decrease);
            console.log(decreaser());
            console.log(decreaser());
            // Javascript의 함수는 위의 조건을 모두 만족하므로 Javascript의 함수는 일급객체이다. 따라서 Javascript의 함수는 흡사 변수와 같이 사용할 수 있으며 코드의 어드에서든지 정의할 수 있다.
            // 함수와 다른 객체를 구분짓는 특징은 호출할 수 있다는 것이다.
        }
    </script>
</body>
</html>